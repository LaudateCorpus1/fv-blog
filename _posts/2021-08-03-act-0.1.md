---
layout: post
published: true
title: Act 0.1 Released
date: '2021-08-03'
author: David Terry
category: 'Research & Development'
---

We have just published the first release of the Act specification language!

Act is a formal specification language, designed to allow for the construction of an exhaustive,
mathematically rigorous description of a smart contract system. Act allows diverse toolchains to
interoperate on a single specification, with each generating and exchanging different kinds of
knowledge. It has a built in analysis engine that can automatically prove properties about the
specification itself, as well as an integrated symbolic execution engine (based on
[hevm](https://fv.ethereum.org/2020/07/28/symbolic-hevm-release/)) that can prove equivalence
between a specification and a given bytecode object. Finally, specifications can be exported into
the Coq proof assistant, allowing for the verification of properties of almost arbitrary complexity,
all with a proof chain right down to the bytecode level.

While a lot of work still remains to be done before act can be used to verify properties on
realistic contracts, we're excited to share what we have, and invite feedback and ideas from the
community.

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Contents**

- [Motivation & Design Philosophy](#motivation--design-philosophy)
  - [Ease of Refinement](#ease-of-refinement)
  - [Modularity](#modularity)
  - [Expresiveness](#expresiveness)
- [Installation](#installation)
- [Language](#language)
  - [Types](#types)
- [Bytecode Level Proof](#bytecode-level-proof)
- [Automated Analysis](#automated-analysis)
  - [Syntax](#syntax)
  - [Implementation](#implementation)
  - [Proving The Constant Product Invariant](#proving-the-constant-product-invariant)
  - [Underpowered Invariants](#underpowered-invariants)
- [Coq Export](#coq-export)
  - [A Brief Introduction to Proof in Coq](#a-brief-introduction-to-proof-in-coq)
  - [Act Export](#act-export)
- [Future Work](#future-work)
  - [Automated Spec Generation](#automated-spec-generation)
  - [Automated Checks for Spec Integrity](#automated-checks-for-spec-integrity)
  - [Support for Dynamic / Compound Types](#support-for-dynamic--compound-types)
  - [Multi Contract Specifications](#multi-contract-specifications)
  - [Rounding Error Analysis](#rounding-error-analysis)
  - [Calls Into Unknown Code](#calls-into-unknown-code)
  - [Loops and Loop Invariants](#loops-and-loop-invariants)
  - [Economic Analysis](#economic-analysis)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Motivation & Design Philosophy

Smart contract development is difficult. The code we write is deployed in one of the most
adverserial environments possible, and must simultaneously secure potentially billions of dollars.
In this context being able to define and prove the correctness of key security properties is
enourmously valuable. Act grew out of the verification work carried out for multi colateral
dai and uniswap v2, and is a ground up rewrite in haskell of the prototype specification language
developed as a part of this process, incorporating many of the lessons learned along the way.

The following are some key design goals:

### Ease of Refinement

Proving properties directly against EVM bytecode is difficult and expensive. Compiler output
contains much extraneous detail (e.g. overflow checks, bitmasks in storage access routines, function
selector dispatch logic) that is not generally relevant when proving the correctness of a high level
property, but that must still be taken into account. A widely used and powerful technique is to use
a process of refinement, where the properties of interest are proven against a high level
specification that abstracts much of this detail away. A seperate proof can then be carried out to
show that a given bytecode object faithfully implements the abstract specification. The
[SeL4](https://sel4.systems/) microkernel is a notable real world application of this technique,
where properties are proven against a high level spec in the Isabelle proof assistant, and then
successive refinement steps (high level spec -> haskell implementation -> C implementation
-> binary compiler output) are used to prove these properties down to the binary level.

Act is a framework designed to allow for easy refinement. We want to make it as easy as possible for
development teams to prove properties against a high level specification, and then to build a proof
chain between this specification and an implementation of the spec in EVM bytecode.

### Modularity

Different tools and techniques have different strengths and weaknesses, and with Act we want to make
it as easy as possible to combine tools and share knowledge between them. For example an SMT based
analysis engine will usually be significantly faster and more convenient than a manual proof in a
tool like Coq, but the later can prove the correctness of statements that would be impossible to
even state in the language accepted by an SMT solver.

With Act as an intermediate language, we can combine and share knowledge from many different tools
and frameworks in a way that allows us to leverage their different strengths where it makes most
sense.

### Expresiveness

Much of the work that we have released to date has been focused on ease of use, and for that reason
we have tried to make it easy for smart contract developers to prove statements in the language that
they are most familiar with (e.g. the
[SMTChecker](https://docs.soliditylang.org/en/v0.8.6/smtchecker.html) built directly into solc, or
the [integration of symbolic
execution](https://fv.ethereum.org/2020/12/11/symbolic-execution-with-ds-test/) into the ds-test
unit test framework). While this makes it easy to get fast results, and allows developers to quickly
build confidence in their implementation, there are limits to which kind of properties can be
expressed in such a framework. For example, some properties may require a greater numeric range than
the 256 bit integers available in the EVM allow, or others may require temporal or quantification
operators that are simply not expressible in a language like solidity.

With Act we hope to provide a language expressive enough to natively express a wide range of
properties, and combined with it's ability to export the specification into the Coq proof assistant
we believe that it should be possible to state almost any property about a given specification.

## Installation

Act can currently be installed via [nix](https://nixos.org/guides/install-nix.html) with the
following commands:

```
# configure nix to use prebuilt binaries for hevm (optional)
nix-shell -p cachix --command "cachix add dapp"

# install act v0.1
nix-env -iA act -if https://api.github.com/repos/ethereum/act/tarball/v0.1
```

If you want to play around with the examples in this blogpost, you can checkout the
[act-examples](TODO!) repo. A call to `nix-shell` from the repository root will drop you into an
environment with all required tools installed and configured.

## Language

A specification of a contract written in act consists of a constructor and a set of behaviours:

- The constructor specification defines the structure of the contract state, the initial value for
  the state, and a list of invariants that the contract should satisfy.

- Each behaviour specification determines how a contract method updates the state, and its return
  value, and the conditions that must be satisfied in order for it to be applied.

Alternatively, they can be thought of an initial state and a set of state transitions, determining
an inductively defined state transition system.

A more detailed level language reference can be found [here](https://github.com/ethereum/act/blob/master/docs/act.md).

### Types

The types of Act consist of three basic primitives: Integers, Booleans and ByteStrings. Integers are
unbounded, with true integer operations. However, as our integer expressions will often represent
words in the EVM, we allow ourselves a slight abuse of notation and denote by `uintN`/`intN` integers
together with the constraint that the value fits into a `uintN`/`intN`.

Using conventional ABI types for typing also allows us to specify function signatures in a concise way.

As an example consider this specification of a trivial contract that adds two numbers and stores the result on chain:

```act
constructor of Add
interface constructor()

creates

  uint result := 0
```
```act
behaviour add of Add
interface add(uint x, uint y)

iff in range uint

   x + y

storage

  result => x + y

returns x + y
```

In more verbose terms, this specification would read:

The contract `Add` has a single state variable, named `result`, which is an integer s.t. `0 <= result < 2^256`.

Given any pair of integers `x` and `y`, s.t. `0 <= x < 2^256` and `0 <= y < 2^256`, an ABI encoded
call to the contract `Add` with the signature `add(uint256,uint256)`, and `x` and `y`, will:

- store `x + y` in `result` and return `x + y` if `0 <= x + y < 2^256`
- revert otherwise

## Bytecode Level Proof

Act leverages the [symbolic execution engine in
hevm](https://fv.ethereum.org/2020/07/28/symbolic-hevm-release/) to provide a backend that can prove
equivalence between a contract specification and an implementation of that specification in EVM.

Two proofs are generated for each behaviour, a `Pass` and a `Fail` proof. The `Pass` proof states
that if all preconditions in the `iff` block are true, then all executions will succeed, storage
will be updated according to the `storage` block, and the expected value will be returned. The
`Fail` proof states that should any of the preconditions be false, all executions will revert.

In both cases we start by first constraining calldata to be of the form specified in the behaviours'
`interface` block (i.e. a concrete selector with abstract types), making the relevant assumptions
depending on whether the proof is a `Pass` or `Fail` kind, and then symbolically executing
the bytecode object with storage held to be completely abstract.

This produces a tree of potential executions where each node in the tree is a potential branching
point, and the each leaf is a contract state. The leaves of the tree represent all possible post
states of the contract after the execution of a single call.

In the case of a `Fail` spec, we then can check that each leaf on the tree is in a reverted state, and
for a `Pass` spec we can check that storage has been updated as expected, and that the contents of
the return buffer match that defined in the behaviours `returns` block.

As an example, consider the following contract:

```solidity
contract Simple {
    uint val;

    function set(uint x) external payable returns (uint) {
        val = x;
        return x;
    }
}
```

We can represent this in act as:

```act
constructor of Simple
interface constructor()

creates

  uint val := 0
```

```act
behaviour set of Simple
interface set(uint x)

storage

  val => x

returns x
```

Act needs to have access to the storage layout metadata output by solc to compute the position in
storage of the various storage variables, so we need to pass a solc output json when trying to prove
equivalence. In the examples repo you can run `dapp build` and then `act hevm --spec src/simple.act
--soljson out/dapp.sol.json` to attempt to prove equivalence between the spec and the runtime
bytecode:

```
TODO:
```

If we try to prove equivalence against a faulty implementation like the one below:

```solidity
contract Simple {
    uint val;

    function set(uint x) external payable returns (uint) {
        if (x == 7) {
          val = x + 1;
        } else {
          val = x;
        }
        return x;
    }
}
```

Then Act will give us a counter example showing a case where the implementation differs from the
specification:

```
TODO:
```

## Automated Analysis

Act has an integrated analysis engine that is currently able to automatically prove two kinds of
property:

- Behaviour level postconditions (i.e. properties that are always true in every possible poststate of a single behaviour)
- Contract level invariants (i.e. properties that are always true for every possible contract state)

### Syntax

Postconditions are defined at the behaviour level in the `ensures` block. All references to storage
in an `ensures` block must to specify whether they talk about the variable's value in the pre- or
the poststate, by using `pre(x)` or `post(x)`.

An example:

```act
behaviour f of F
interface f(uint z)

storage

  y => z
  x => 30 * z

ensures

  post(x) == 30 * post(y)
```

Invariants are defined in the `invariants` block in the constructor specification. Each invariant is
a predicate that should hold for every possible contract state. Invariant predicates have access to
the constructor's calldata. Note that since invariant predicates are defined over a single abstract
contract state (instead of a pair of states as with the predicates in the `ensures` block), we do
not need to disambiguate storage references with `pre` and `post`.

An example:

```act
constructor of C
interface constructor(uint _x, uint _y, uint _z)

iff _x * _y == _z

creates

  uint x := _x
  uint y := _y

invariants

  x * y == _z
```

### Implementation

In order to discharge these proofs, we construct an
[SMT](https://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories) based encoding of each behaviour
in the spec, and then dispatch queries based on this encoding to an SMT solver (currently z3 and
cvc4 are supported).

For the postcondition claims, we tell the solver to assume that all preconditions are true, and that
all storage updates have occurred as defined in the `storage` block, and then ask it to find
an assignment for the abstract variables in the spec (calldata, environment, and storage) that would
lead to a violation of the postcondition. If none can be found, then we have a proof that the
postcondition always holds.

For the invariant claims, we attempt to construct an inductive proof. We first ask the solver to
find an assignment for the variables in the constructor that would result in a violation of the
invariant predicate, if none can be found we have a proof of the base case. Then for the inductive
step we construct a query for each behaviour that assumes preconditions and storage rewrites, and
additionally assumes that the invariant claim is true over the prestate. We then ask the solver to
find an assignment for the variables in the behaviour that would result in a violation of the
invariant predicate over the storage post state. If none can be found, we have an inductive proof
that the invariant must hold over all possible contract states.

### Proving The Constant Product Invariant

As an example consider the following specification of a highly simplified uniswap style [constant
product](https://www.paradigm.xyz/2021/07/twamm/#The_Constant_Product_Formula) automatic market
maker. For the purposes of this example we focus only on the core logic, and ignore e.g.
interactions with the underlying tokens.

The `Amm` has two state variables representing its underlying token balances, `reserve0` and
`reserve1`. These are initialized to `1000` units each upon creation.

We define a single invariant, that the product of the two reserves should never decrease. This is an
important safety property, if it is violated, an attacker will be able to execute a sequence of
trades that can drain all funds from the exchange.

```act
behaviour init of Amm
interface constructor()

creates

    uint256 reserve0 := 1000
    uint256 reserve1 := 1000

invariants

    1000 * 1000 <= reserve0 * reserve1
```

Next, we define the two `swap` methods, that allow a user to exchange tokens. These methods take an
amount (`amt`) of input reserves, and the `Amm` will adjust the size of the other reserve according
to the `x * y == k` constant product formula.

```act
behaviour swap0 of Amm
interface swap0(uint256 amt)

iff in range uint256

    reserve0 + amt

storage

    reserve0 => reserve0 + amt
    reserve1 => (reserve0 * reserve1) / (reserve0 + amt)
```

```act
behaviour swap1 of Amm
interface swap1(uint256 amt)

iff in range uint256

    reserve1 + amt

storage

    reserve0 => (reserve0 * reserve1) / (reserve1 + amt)
    reserve1 => reserve1 + amt
```

If we run `act prove` against the above spec, we find that there is in fact an error:

```
TODO!
```

If the `Amm` starts with `reserve0 == 1` and `reserve1 == 1,000,000`, and `swap0` is called with
`amt == 2`, the final state of the `Amm` will be `reserve0 == 3` and `reserve1 == 333,333`. In this
case `3 * 333,333` is `999,999`, and in fact the product of the reserves has decreased slightly due
to imprecision introduced by the EVM's flooring division.

A safe specification for the `swap` methods is as follows. Notice the extra `+ 1` added to the output
reserve in both cases. With this implementation, the rounding error is now in favor of the pool
instead of the trader, and the contract is now safe against this particular attack.

```act
behaviour swap0 of Amm
interface swap0(uint256 amt)

iff in range uint256

    reserve0 + amt

storage

    reserve0 => reserve0 + amt
    reserve1 => (reserve0 * reserve1) / (reserve0 + amt) + 1
```

```act
behaviour swap1 of Amm
interface swap1(uint256 amt)

iff in range uint256

    reserve1 + amt

storage

    reserve0 => (reserve0 * reserve1) / (reserve1 + amt) + 1
    reserve1 => reserve1 + amt
```

If we again run `act prove` against the fixed specification, we see that the invariant holds for all
possible executions of the contract:

```
TODO!
```

### Underpowered Invariants

Due to the inductive nature of the proof, there are some true invariants that the SMT backend is
unable to prove. For example, consider the following state machine:

```act
behaviour init of C
interface constructor()

creates

  uint x := 0

invariants

  x < 9
```

```act
behaviour f of C
interface f()

case x == 0:

  storage

    x => 1
```

```act
behaviour g of C
interface g()

case x == 1:

  storage

    x => 2
```

```act
behaviour j of C
interface j()

case x == 7:

  storage

    x => 100
```

The contract `C` can never be in a state where `x == 7` and so the write of `100` to `x` in `j()` can
never occur, however if we run `act prove` against this specification, this exact case (`x == 7`) is
found as a counterexample.

This is due to the inductive nature of the proof: Act checks that the invariant holds after
running the constructor, and then for each method assumes that the invariant holds over the pre state
and checks that the invariant holds over the post state.

In the case above, the invariant states that `x < 9`, and if this is assumed as a precondition, then
the `x == 7` branch in `j()` is still reachable.

We can fix this by strengthening the invariant to make the `x == 7` branch unreachable, in the case
of the spec above, an invariant of `x < 7` is sufficient, although `x < 3` is the strongest
invariant of this form that holds over the full transition system.

## Coq Export

While the automated proof backend is quite capable, there are still many properties that are too
challenging for automated tools. For this reason Act allows exporting the transition system to the
Coq proof assistant, where manual proofs of almost arbitrary complexity can be carried out.

A proof assistant provides tools that help with both the construction and checking of a proof. Given
a set of axioms and assumptions, and a theorem, the user can attempt to construct a proof of the
theorem by applying various tactics and proof rules to transform their theorem into something that
the proof assistant will accept as true.  This procedure is usually highly interactive, where the
user will incrementally build the proof step by step, with the assistant giving instant feedback as
the proof progresses.

A proof constructed in a mainstream proof assistant like Coq or Isabelle is considered by many to be
the most rigorous form of proof. These tools will only accept proofs that are constructed entirely
from transformations that are considered valid within the logical system that each tool implements,
which is generally stricter than many pen and paper mathematical proofs, which will often skip the
full details of a particularly tedious section. The proof checking is carried out in a minimal and
extremely well audited proof kernel, and as long as the kernel is bug free, the rest of the code in
the proof assistant can be considered as untrusted.

### A Brief Introduction to Proof in Coq

Coq is a complex system with a non trivial learning curve, while a full tutorial on programming in
Coq is out of the scope of this blog post, we can give a little taste of how things work. For a more
thorough introduction the books [Software Foundations](https://softwarefoundations.cis.upenn.edu/)
and [Certified Programming With Dependent Types](http://adam.chlipala.net/cpdt/) are both excellent.
Software Foundations in particular is a great introduction for users with little experience in the
fields of formal logic and proof.

Coq contains two languages: a minimal functional specification and programming language called
Gallina, and a tactics language that can be used to build and manipulate proofs (Ltac). Lets start
from the very basics by defining the natural numbers and proving a fact about addition.

We start by defining the type of natural numbers, we do this by providing the data constructors
through which objects of this type can be instantiated. We define two constructors: `O`,
representing `0`, and `S`, which when applied to the natural number `n` produces the representation of
the number `n + 1` (the Successor). To give a concrete example `3` would be represented in this
encoding as `S (S (S 0)))` i.e `1 + 1 + 1 + 0`.

```Coq
Inductive nat : Type :=
  | O
  | S (n : nat).
```

This is an example of a [unary](https://en.wikipedia.org/wiki/Unary_numeral_system) number
representation.  It can often be helpful to represent numbers this way, since the inductive nature
of the definition lends itself to inductive proof techniques.

Lets continue by defining addition over our `nat` type:

```Coq
Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
  | O ⇒ m
  | S n' ⇒ S (plus n' m)
  end.
```

Here we define a recursive function (a `Fixpoint` in Gallina) that takes two numbers `n` and `m` and
returns the sum of these two numbers. The implementation is defined recursively with pattern
matching, and essentially takes all the `S` constructors in `n` and applies them directly to `m`.

Now we're ready to prove something! Lets prove that `0 + n == n`:

```Coq
Theorem plus_O_n :
  forall n : nat, plus O n = n.
Proof.
  intros n. simpl. reflexivity.
Qed.
```

We first define our theorem and give it a name (`plus_O_n`). Then we define the proof goal, we state
that for all `n`, where `n` is an instance of our `nat` type, `0 + n` is the same as `n`. Finally we
define the proof, this is an expression in the tactic language, where each statement is transforming
the proof goal in some way. The exact mechanics of the proof are a little difficult to explain
without hands on access to a running instance of the proof assistant (where you can see how each
step in the proof transforms the goal), but in this case the goal is simple enough that Coq is quite
easily able to simplify `plus O n` into `n`, leaving us `n = n`, which Coq is once again able to
simplify into `true`, allowing us to call `reflexivity` to end the proof.

Of course real world development in Coq does not generally require proving basic facts about
arithmetic, Coq contains a large standard library, where many useful definitions and theorems
are provided out of the box. However the above example hopefully does illustrate that when working
with Coq we get nothing for free, and in many cases it can be quite hard to convince the proof
engine of the correctness of a statement that you can intuitively see is "obviously" true.

### Act Export

Lets take a look at using Coq to prove properties about a specification that is too difficult for
the SMT backend. The following defines a contract that implements exponentiation via repeated
multiplication. The contract is initialized with a base (`b`) and an exponent (`e`). `exp()` can
then be repeatedly called until `e` is `1`, and the result can then be read from the storage
variable `r`. While obviously artificial, this example does highlight a key shortcoming of the SMT
based analysis: exponentiation with a symbolic exponent is simply unexpressible in the smt-lib
language used by all major SMT solvers, and so any contract making use of exponentiation where the
exponent is a variable of some kind (e.g. calldata, storage) will be impossible to verify using SMT.
Coq has no such restrictions, and we can export the spec below and prove correctness there.

```act
constructor of Exponent
interface constructor(uint _b, uint _e)

iff

    _e > 0

creates

    uint b := _b
    uint e := _e
    uint r := _b
```

```act
behaviour exp of Exponent
interface exp()

iff

    e > 1

iff in range uint

    r * b
    e - 1

storage

    r => r * b
    e => e - 1
    b
```

You can export the spec into Coq by running `make Exponent.v` in the `src/exponent` directory of the examples repo.
This will create a file called `Exponent.v` which contains a model of the above act specification in
Coq:

```Coq
(* --- GENERATED BY ACT --- *)

Require Import Coq.ZArith.ZArith.
Require Import ActLib.ActLib.
Require Coq.Strings.String.

Module Str := Coq.Strings.String.
Open Scope Z_scope.

Record State : Set := state
{ b : Z
; e : Z
; r : Z
}.

Definition exp0 (STATE : State)  :=
state (b STATE) (((e STATE) - 1)) (((r STATE) * (b STATE))).

Definition Exponent0 (_b : Z) (_e : Z) :=
state (_b) (_e) (_b).

Inductive reachable  : State -> State -> Prop :=
| Exponent0_base : forall (_b : Z) (_e : Z),
     (_e > 0)
  -> ((0 <= _b) /\ (_b <= (UINT_MAX 256)))
  -> ((0 <= _e) /\ (_e <= (UINT_MAX 256)))
  -> reachable (Exponent0 _b _e) (Exponent0 _b _e)

| exp0_step : forall (BASE STATE : State),
     reachable BASE STATE
  -> ((e STATE) > 1)
  -> ((0 <= ((r STATE) * (b STATE))) /\ (((r STATE) * (b STATE)) <= (UINT_MAX 256)))
  -> ((0 <= ((e STATE) - 1)) /\ (((e STATE) - 1) <= (UINT_MAX 256)))
  -> ((0 <= (r STATE)) /\ ((r STATE) <= (UINT_MAX 256)))
  -> ((0 <= (e STATE)) /\ ((e STATE) <= (UINT_MAX 256)))
  -> ((0 <= (b STATE)) /\ ((b STATE) <= (UINT_MAX 256)))
  -> reachable BASE (exp0 STATE )
.
```

Let's break this down a bit. We have a definition of contract storage `State`, which consists of
three variables `b`, `e` and `r`, all of type `Z`. `Z` is an integer type using a binary encoding
from the [`ZArith`](https://coq.inria.fr/library/Coq.ZArith.ZArith_base.html#) library bundled with
Coq.

Next we have `exp0`, which defines how state is updated by the `exp` behaviour, and `Exponent0`
which defines how the state variables are initialized by the constructor arguments.

Finally we have an [Inductive Proposition](https://softwarefoundations.cis.upenn.edu/lf-current/IndProp.html)
`reachable` that defines the conditions under which a certain state is reachable from another. There
are two parts to this definition:

- `Exponent0_base`: states that given two integers `_b` and `_e`, the initial state is reachable
    from the initial state if `_e` and `_b` are in the range of a `uint256` and `_e` is greater than `0`.
- `exp0_step`: states that for a pair of states `BASE` and `STATE`, `exp0 STATE` (i.e. the result of
    calling `exp()` against an arbitrary contract state) is reachable from `BASE` if `STATE` is
    reachable from `BASE`, all the state variables in `STATE` (`e`, `b`, `r`) are within the range
    of a `uint256`, result of the calculations `r * b` and `e - 1` are within the range of a
    `uint256`, and that `e` is greater than `1`.

This gives us a pair of [inference rules](https://en.wikipedia.org/wiki/Inference_rules) that we can
use to prove facts about the set of reachable states defined by the specification for the `Exponent`
contract.

An example of such a proof is contained in the `Theory.v` file in the examples repo. The core fact
that we wish to prove is that when `e` is `1`, `r` is equal to `b ^ e`. This can be expressed in coq
as:

```Coq
forall (base, s : State),
  reachable base s -> e s = 1 -> r s = (b base) ^ (e base).
```

Expressed more verbosely: for all states `base` and `s`, if `s` is reachable from `base`, and the
value of `e` in `s` is `1` then the result variable `r` in `s` has the value of `b` from `base`
raised to the power of `e` from `base`.

The full proof is reproduced below. While an explanation of each step is out of scope for this post
(and is anyway best made with the proof loaded into an interactive instance of the Coq prover like
[proof general](https://proofgeneral.github.io/) or
[CoqIde](https://coq.inria.fr/refman/practical-tools/coqide.html)), we can give a broad strokes overview.

We must first define a simple helper fact `pow_pred` that states simply that given two integers `a`
and `e`, if `e` is greater than `0` then `a * a ^ (e -1)` is the same as `a ^ e`. This fact is
needed in the later steps of the proof. The next step is to define a [loop
invariant](https://en.wikipedia.org/wiki/Loop_invariant) for `exp()` (i.e. a fact that is true
before and after each loop iteration). This is the Lemma `invariant`, which states that for every
state `s` reachable from `base`, `r * b ^ (e - 1)` over `s` is equal to `b ^ e` over `base`.
Intuitively, this states that the partial result calculated so far (`r`), multiplied by the remaining
portion of the input calculation `b ^ (e - 1)` is equal to the final expected result. Finally, given
these two intermediate facts, we can discharge a proof for the correctness of `Exponent` as defined
above.

```Coq
Require Import Exponent.Exponent.
Require Import ActLib.ActLib.
Require Import Coq.ZArith.ZArith.
Open Scope Z_scope.

Lemma pow_pred : forall a e, 0 < e -> a * a ^ (Z.pred e) = a ^ e.
Proof.
  intros.
  apply eq_sym.
  replace (a ^ e) with (a ^ (Z.succ (Z.pred e))).
  - apply Z.pow_succ_r.
    apply Zlt_0_le_0_pred.
    assumption.
  - rewrite (Z.succ_pred e).
    reflexivity.
Qed.

Lemma invariant : forall base s,
  reachable base s -> (r s) * (b s) ^ ((e s) - 1) = (b base) ^ (e base).
Proof.
  intros base s H. induction H.
  - simpl.
    rewrite Z.sub_1_r.
    apply pow_pred.
    apply Z.gt_lt.
    assumption.
  - simpl.
    rewrite <- IHreachable.
    rewrite Z.sub_1_r.
    rewrite <- (pow_pred (b STATE) (e STATE - 1)).
    + rewrite Z.mul_assoc. reflexivity.
    + apply Z.gt_lt in H0.
      apply (proj1 (Z.sub_lt_mono_r 1 (e STATE) 1)).
      assumption.
Qed.

Theorem exp_correct : forall base s,
  reachable base s -> e s = 1 -> r s = (b base) ^ (e base).
Proof.
  intros base s H He.
  apply invariant in H.
  rewrite He in H. simpl in H.
  rewrite (Z.mul_1_r (r s)) in H.
  assumption.
Qed. Check exp_correct.
```

While this may seem like quite a lot of work to prove what looks like a pretty simple and obvious
fact it is worth noting two things:

1. A proof of this property is beyond the reach of any automated tool available today
2. Our mind is full of hidden assumptions, and facts that may seem obvious are not always so. This
   is not the case for the Coq proof kernel, and once we have convinced it that something is true,
   we can be very sure that it really is.

## Future Work

### Automated Spec Generation

Act is designed to be simple and explicit. While this supports automated analysis based on the act
specifications, it does mean that writing specifications by hand often involves quite some
boilerplate. In many cases we are mostly interested in whether a given bytecode object
satisfies some high level properties, and keeping both the implementation and specification in sync
can introduce unwanted overhead to the development process.

For this reason we intend to build an automated spec generation engine into hevm that will utilise
the symbolic execution engine to produce an exhaustive description of all possible execution paths
as a set of act specifications. This should allow for fast iteration on the implementation, while
allowing for high level analysis of that implementation with Coq and the Act smt backend.

There are some additional benefits to this approach. The current symbolic execution backend
represents our first attempt at a bytecode level proof engine for act. Unfortunately while building
this out we encountered a fundamental issue: while act specs are expressed in terms of unbounded
integers, the symbolic execution engine in hevm uses bitvectors. This means that checking
equivalence between a given bytecode object and a set of act specs requires conversions from
integers to bitvectors. While this is tractable for simple specs, it quickly overwhelms the SMT
solver for any non-trivial contract (including any safe arithmetic!).

An automated spec generation engine allows us to nicely sidestep this issue, we no longer have to
prove equivalence between bytecode and specs, since the specs themselves have been generated
directly from the bytecode and are therefore "correct by construction". Even in the case where specs
have been written by hand, we would still only need to prove equivalence between two sets of specs
(both of which are written in terms of Integers), once again allowing us to avoid the troublesome
`bv_to_int` and `int_to_bv` smt operations.

### Automated Checks for Spec Integrity

There are currently many specs that typecheck but are still malformed and would invalidate the
proofs derived from them. We intend to add automated analysis passes to detect issues of this kind.
At the moment we currently have the following planned:

- Arithmetic overflow detection ([#109](https://github.com/ethereum/act/issues/111))
- Case consistency checks ([#110](https://github.com/ethereum/act/issues/111))
- Collisions in mapping assignments ([#111](https://github.com/ethereum/act/issues/111))

### Support for Dynamic / Compound Types

While we have some support at the syntax level for specifications involving dynamic types (e.g. `string`
or `bytes`), the various proof backends do not currently support proof involving these types.

We also intend to add support for compound types (e.g. array / struct / tuple) to the language and
proof backends.

### Multi Contract Specifications

Similarly to dynamic and compound types, while syntax does exist that allows for specification of
multi contract systems, these features are not well supported in the various analysis backends.

### Rounding Error Analysis

Understanding the impact of rounding error in a smart contract is a critical task for secure
development.  As we saw in the `AMM` example above, numeric error introduced by precision loss can
result in unexpected violations of important security properties.

There are generally two properties of interest:

- The direction of the rounding error (who loses out)
- The size of the rounding error (by how much do they lose)

We intend to allow users to specify properties relating to rounding by introducing a new operator
(e.g. `exact`, or `toReal`), which would indicate that the numeric expression contained within
should be expressed in various backends using Reals instead of Ints. This would for example allow
for properties that assert statements about the size and direction of the difference between the
result of the calculation over the real numbers and it's rounded result when expressed over the
integers.

For a manual example of a similar analysis, see the [uniswap v1
model](https://github.com/runtimeverification/verified-smart-contracts/blob/uniswap/uniswap/x-y-k.pdf)
produced by Runtime Verification.

### Calls Into Unknown Code

Real world smart contracts must often make calls into unknown code, whether for simple tasks like an
eth or token transfer, or for more complex actions (e.g. delegation of control for a flash loan).
Each time they do so, they pass control to potentially malicious code that can make arbitrary
modifications to the execution context, something that obviously has deep implications for the
security of the calling contract. If we wish to prove security properties about realistic
smart contracts with Act, we must therefore be able to specify behaviour that includes such calls.

We intend to introduce language constructs and verification routines that will allow specification
and proof of properties relating to such contracts. Some ideas can be found
[here](https://github.com/ethereum/act/issues/18).

### Loops and Loop Invariants

Although generally inadvisable, loops are sometimes unavoidable when developing smart contracts
(e.g. numeric routines). We intend to introduce syntax and verification routines that allow
specification and proof for loop invariants.

Some early thoughts and ideas can be found in these github issues
[#2](https://github.com/ethereum/act/issues/2), [#3](https://github.com/ethereum/act/issues/3).

### Economic Analysis

Act could be extended with a backend that integrates, or exports to an agent based modelling
framework to allow for complex economic analysis. We believe that Act has some unique advantages
here. Simulation could be carried out against the Act expressions (which are generally significantly
simpler than the EVM that they model), allowing for fast execution, while still maintaining a formal
guarantee that the simulation accurately models the deployed implementation.
