---
layout: post
published: true
title: Act 0.1 Released
date: '2021-08-03'
author: David Terry
category: 'Research & Development'
---

We have just published the first release of the Act specification language!

Act is a formal specification language, designed to allow for the construction of an exhaustive,
mathematically rigorous description of a smart contract system. Act has a built in analysis engine
that can automatically prove properties about the specification itself, as well as an integrated symbolic
execution engine (based on [hevm](https://fv.ethereum.org/2020/07/28/symbolic-hevm-release/)) that
can prove equivalence between a specification and a given bytecode object. Finally, Act specs can be
exported into the Coq proof assistant, allowing for the verification of properties of almost
arbitrary complexity, all with a proof chain right down to the bytecode level.

Act is designed to allow for easy interoperability between diverse analysis toolchains, in the
future, Act could be extended with additional backends, for example a symbolic model checker could
allow reasoning about temporal properties, or an agent based modelling framework could allow for
complex economic analysis.

While a lot of work still remains to be done before act can be used to verify properties on
realistic contracts, we're excited to share what we have, and invite feedback and ideas from the
community.

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Contents**

- [Language](#language)
  - [Types](#types)
- [Bytecode Level Proof](#bytecode-level-proof)
- [Automated Analysis Engine](#automated-analysis-engine)
  - [Syntax](#syntax)
  - [Implementation](#implementation)
  - [Proving The Constant Product Invariant](#proving-the-constant-product-invariant)
  - [Underpowered Invariants](#underpowered-invariants)
- [Proof Assistant Export](#proof-assistant-export)
  - [A Brief Introduction to Proof in Coq](#a-brief-introduction-to-proof-in-coq)
  - [Act Export](#act-export)
- [Future Work](#future-work)
  - [Automated Spec Generation](#automated-spec-generation)
  - [Automated Checks for Spec Integrity](#automated-checks-for-spec-integrity)
  - [Support for Dynamic / Compound Types](#support-for-dynamic--compound-types)
  - [Multi Contract Specifications](#multi-contract-specifications)
  - [Rounding Error Analysis](#rounding-error-analysis)
  - [Calls Into Unknown Code](#calls-into-unknown-code)
  - [Loops and Loop Invariants](#loops-and-loop-invariants)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


## Language

Act is a specification language, meaning that it is intended to allow for a precise and expressive
description of program behaviour, but there is no automated compilation pipeline allowing for
the production of EVM bytecode from an Act specification.

A specification of a contract written in act consists of a constructor and a set of behaviours:

- The constructor specification defines the structure of the contract state, the initial value for
  the state, and a list of invariants that the contract should satisfy.

- Each behaviour specification determines how a contract method updates the state, and its return
  value, and the conditions that must be satisfied in order for it to be applied.

Alternatively, they can be thought of an initial state and a set of state transitions, determining
an inductively defined state transition system.

A more detailed level language reference can be found [here](https://github.com/ethereum/act/blob/master/docs/act.md).

### Types

The types of Act consist of three basic primitives: Integers, Booleans and ByteStrings. Integers are
unbounded, with true integer operations. However, as our integer expressions will often represent
words in the EVM, we allow ourselves a slight abuse of notation and denote by `uintN`/`intN` integers
together with the constraint that the value fits into a `uintN`/`intN`.

Using conventional ABI types for typing also allows us to specify function signatures in a concise way.

As an example consider the specification of overflow safe addition:

```act
behaviour add of SafeMath
interface add(uint x, uint y)

iff in range uint

   x + y

returns x + y
```

In more verbose terms, this specification would read:

Given any pair of integers `x` and `y`, s.t. `0 <= x < 2^256` and `0 <= y < 2^256`, an ABI encoded
call to the contract SafeMath with the signature `add(uint256,uint256)`, and `x` and `y`, will:

- return `x + y` if `0 <= x + y < 2^256`
- revert otherwise

## Bytecode Level Proof

Act leverages the [symbolic execution engine in
hevm](https://fv.ethereum.org/2020/07/28/symbolic-hevm-release/) to provide a backend that can prove
equivalence between a contract specification and an implementation of that specification in EVM.

Two proofs are generated for each behaviour, a `Pass` and a `Fail` proof. The `Pass` proof states
that if all preconditions in the `iff` block are true, then all executions will succeed, storage
will be updated according to the `storage` block, and the expected value will be returned. The
`Fail` proof states that should any of the preconditions be false, all executions will revert.

In both cases we start by first constraining calldata to be of the form specified in the behaviours'
`interface` block (i.e. a concrete selector with abstract types), making the relevant assumptions
depending on whether the proof is a `Pass` or `Fail` kind, and then symbolically executing
the bytecode object with storage held to be completely abstract.

This produces a tree of potential executions where each node in the tree is a potential branching
point, and the each leaf is a contract state. The leaves of the tree represent all possible post
states of the contract after the execution of a single call.

In the case of a `Fail` spec, we then can check that each leaf on the tree is in a reverted state, and
for a `Pass` spec we can check that storage has been updated as expected, and that the contents of
the return buffer match that defined in the behaviours `returns` block.

As an example, consider the following contract:

```solidity
contract Simple {
    uint val;

    function set(uint x) external payable returns (uint) {
        val = x;
        return x;
    }
}
```

We can represent this in act as:

```act
constructor of Simple
interface constructor()

creates

  uint val := 0
```

```act
behaviour set of Simple
interface set(uint x)

storage

  val => x

returns x
```

Act needs to have access to the storage layout metadata output by solc to compute the position in
storage of the various storage variables, so we need to pass a solc output json when trying to prove
equivalence. In the examples repo you can run `dapp build` and then `act hevm --spec src/simple.act
--soljson out/dapp.sol.json` to attempt to prove equivalence between the spec and the runtime
bytecode:

```
TODO:
```

If we try to prove equivalence against a faulty implementation like the one below:

```solidity
contract Simple {
    uint val;

    function set(uint x) external payable returns (uint) {
        if (x == 7) {
          val = x + 1;
        } else {
          val = x;
        }
        return x;
    }
}
```

Then Act will give us a counter example showing a case where the implementation differs from the
specification:

```
TODO:
```

## Automated Analysis Engine

Act has an integrated analysis engine that is currently able to automatically prove two kinds of
property:

- Behaviour level postconditions (i.e. properties that are always true in every possible poststate of a single behaviour)
- Contract level invariants (i.e. properties that are always true for every possible contract state)

### Syntax

Postconditions are defined at the behaviour level in the `ensures` block. All references to storage
in an `ensures` block must to specify whether they talk about the variable's value in the pre- or
the poststate, by using `pre(x)` or `post(x)`.

An example:

```act
behaviour f of F
interface f(uint z)

storage

  y => z
  x => 30 * z

ensures

  post(x) == 30 * post(y)
```

Invariants are defined in the `invariants` block in the constructor specification. Each invariant is
a predicate that should hold for every possible contract state. Invariant predicates have access to
the constructor's calldata. Note that since invariant predicates are defined over a single abstract
contract state (instead of a pair of states as with the predicates in the `ensures` block), we do
not need to disambiguate storage references with `pre` and `post`.

An example:

```act
constructor of C
interface constructor(uint _x, uint _y, uint _z)

iff _x * _y == _z

creates

  uint x := _x
  uint y := _y

invariants

  x * y == _z
```

### Implementation

In order to discharge these proofs, we construct an
[SMT](https://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories) based encoding of each behaviour
in the spec, and then dispatch queries based on this encoding to an SMT solver (currently z3 and
cvc4 are supported).

For the postcondition claims, we tell the solver to assume that all preconditions are true, and that
all storage updates have occurred as defined in the `storage` block, and then ask it to find
an assignment for the abstract variables in the spec (calldata, environment, and storage) that would
lead to a violation of the postcondition. If none can be found, then we have a proof that the
postcondition always holds.

For the invariant claims, we attempt to construct an inductive proof. We first ask the solver to
find an assignment for the variables in the constructor that would result in a violation of the
invariant predicate, if none can be found we have a proof of the base case. Then for the inductive
step we construct a query for each behaviour that assumes preconditions and storage rewrites, and
additionally assumes that the invariant claim is true over the prestate. We then ask the solver to
find an assignment for the variables in the behaviour that would result in a violation of the
invariant predicate over the storage post state. If none can be found, we have an inductive proof
that the invariant must hold over all possible contract states.

### Proving The Constant Product Invariant

As an example consider the following specification of a highly simplified uniswap style [constant
product](https://www.paradigm.xyz/2021/07/twamm/#The_Constant_Product_Formula) automatic market
maker. For the purposes of this example we focus only on the core logic, and ignore e.g.
interactions with the underlying tokens.

The `Amm` has two state variables representing its underlying token balances, `reserve0` and
`reserve1`. These are initialized to `1000` units each upon creation.

We define a single invariant, that the product of the two reserves should never decrease. This is an
important safety property, if it is violated, an attacker will be able to execute a sequence of
trades that can drain all funds from the exchange.

```act
behaviour init of Amm
interface constructor()

creates

    uint256 reserve0 := 1000
    uint256 reserve1 := 1000

invariants

    1000 * 1000 <= reserve0 * reserve1
```

Next, we define the two `swap` methods, that allow a user to exchange tokens. These methods take an
amount (`amt`) of input reserves, and the `Amm` will adjust the size of the other reserve according
to the `x * y == k` constant product formula.

```act
behaviour swap0 of Amm
interface swap0(uint256 amt)

iff in range uint256

    reserve0 + amt

storage

    reserve0 => reserve0 + amt
    reserve1 => (reserve0 * reserve1) / (reserve0 + amt)
```

```act
behaviour swap1 of Amm
interface swap1(uint256 amt)

iff in range uint256

    reserve1 + amt

storage

    reserve0 => (reserve0 * reserve1) / (reserve1 + amt)
    reserve1 => reserve1 + amt
```

If we run `act prove` against the above spec, we find that there is in fact an error:

```
TODO!
```

If the `Amm` starts with `reserve0 == 1` and `reserve1 == 1,000,000`, and `swap0` is called with
`amt == 2`, the final state of the `Amm` will be `reserve0 == 3` and `reserve1 == 333,333`. In this
case `3 * 333,333` is `999,999`, and in fact the product of the reserves has decreased slightly due
to imprecision introduced by the EVM's flooring division.

A safe specification for the `swap` methods is as follows. Notice the extra `+ 1` added to the output
reserve in both cases. With this implementation, the rounding error is now in favor of the pool
instead of the trader, and the contract is now safe against this particular attack.

```act
behaviour swap0 of Amm
interface swap0(uint256 amt)

iff in range uint256

    reserve0 + amt

storage

    reserve0 => reserve0 + amt
    reserve1 => (reserve0 * reserve1) / (reserve0 + amt) + 1
```

```act
behaviour swap1 of Amm
interface swap1(uint256 amt)

iff in range uint256

    reserve1 + amt

storage

    reserve0 => (reserve0 * reserve1) / (reserve1 + amt) + 1
    reserve1 => reserve1 + amt
```

If we again run `act prove` against the fixed specification, we see that the invariant holds for all
possible executions of the contract:

```
TODO!
```

### Underpowered Invariants

Due to the inductive nature of the proof, there are some true invariants that the SMT backend is
unable to prove. For example, consider the following state machine:

```act
behaviour init of C
interface constructor()

creates

  uint x := 0

invariants

  x < 9
```

```act
behaviour f of C
interface f()

case x == 0:

  storage

    x => 1
```

```act
behaviour g of C
interface g()

case x == 1:

  storage

    x => 2
```

```act
behaviour j of C
interface j()

case x == 7:

  storage

    x => 100
```

The contract `C` can never be in a state were `x == 7` and so the write of `100` to `x` in `j()` can
never occur, however if we run `act prove` against this specification, this exact case (`x == 7`) is
found as a counterexample.

This is due to the inductive nature of the proof: Act checks that the invariant holds after
running the constructor, and then for each method assumes that the invariant holds over the pre state
and checks that the invariant holds over the post state.

In the case above, the invariant states that `x < 9`, and if this is assumed as a precondition, then
the `x == 7` branch in `j()` is still reachable.

We can fix this by strengthening the invariant to make the `x == 7` branch unreachable, in the case
of the spec above, an invariant of `x < 7` is sufficient, although `x < 3` is the strongest
invariant of this form that holds over the full transition system.


## Proof Assistant Export

While the automated proof backend is quite capable, there are still many properties that are too
challenging for automated tools. For this reason Act allows exporting the transition system to the
Coq proof assistant, where manual proofs of almost arbitrary complexity can be carried out.

A proof assistant provides tools that help with both the construction and checking of a proof. Given
a set of axioms and assumptions, and a theorem, the user can attempt to construct a proof of the
theorem by applying various tactics and proof rules to transform the assumptions into the statement
that they wish to prove. This procedure is generally highly interactive, where the user will
incrementally build the proof step by step, with the assistant giving instant feedback as the proof
progresses.

A proof constructed in a mainstream proof assistant like Coq or Isabelle is generally considered to
be the most rigorous form of proof possible. These tools will only accept proofs that are constructed
entirely from transformations that are considered valid within the logical system that each tool
implements, this is generally much stricter than most pen and paper mathematical proofs, which will
often skip the full details of a particularly tedious section of a proof. The proof checking is
carried out in a minimal and extremely well audited proof kernel, and as long as the kernel is bug
free, the rest of the code in the proof assistant can be considered as untrusted.

### A Brief Introduction to Proof in Coq

Coq is a complex system with a non trivial learning curve, while a full tutorial on programming in
Coq is out of the scope of this blog post, we can give a little taste of how things work. For a more
thorough introduction the books [Software Foundations](https://softwarefoundations.cis.upenn.edu/)
and [Certified Programming With Dependent Types](http://adam.chlipala.net/cpdt/) are both excellent.
Software Foundations in particular is a great introduction for users with little experience in the
fields of formal logic and proof.

Coq contains two languages: a minimal functional programming language called Gallina, and a tactics
language that can be used to build and manipulate proofs. Lets start from the very basics by
defining the natural numbers and proving a fact about addition.

We start by defining the type of natural numbers, we do this by providing the data constructors
through which objects of this type can be instantiated. We define two constructors: `O`,
representing 0, and `S`, which when applied to the natural number `n` produces the representation of
the number `n + 1` (the Successor). To give a concrete example 3 would be represented in this
encoding as `S (S (S 0)))` i.e 1 + 1 + 1 + 0.

```Coq
Inductive nat : Type :=
  | O
  | S (n : nat).
```

This is known as the [unary](https://en.wikipedia.org/wiki/Unary_numeral_system) representation and
is often used when dealing with formal proof since it often makes proof by induction much easier.

Lets continue by defining addition over our `nat` type:

```Coq
Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
  | O ⇒ m
  | S n' ⇒ S (plus n' m)
  end.
```

Here we define a recursive function (`Fixpoint` in Gallina) that takes two numbers `n` and `m` and
returns the sum of these two numbers. The implementation is defined recursively with pattern
matching, and essentially takes all the `S` constructors in `n` and applies them directly to `m`.

Now we're ready to prove something! Lets prove that `0 + n == n`:

```Coq
Theorem plus_O_n :
  ∀ n : nat, plus O n = n.
Proof.
  intros n. simpl. reflexivity.
Qed.
```

We first define our theorem and give it a name (`plus_O_n`. Then we define the proof goal, we state
that for all `n`, where `n` is an instance of our `nat` type, `0 + n` is the same as `n`. Finally we
define the proof, this is an expression in the tactic language, where each statement is transforming
the proof goal in some way. The exact mechanics of the proof are a little difficult to explain
without hands on access to a running instance of the proof assistant (where you can see how each
step in the proof transforms the goal), but in this case the goal is simple enough that Coq is quite
easily able to simplify `plus O n` into `n`, leaving us with a proof goal that is simply `true`, and
allowing us to call `reflexivity` to end the proof.

Of course real world development in Coq does not generally require proving basic facts about
arithmetic, Coq contains a large standard library, where many useful definitions and theorems
are provided out of the box. However the above example hopefully does illustrate that when working
with Coq we get nothing for free, and in many cases it can be quite hard to convince the proof
engine of the correctness of a statement that you can intuitively see is "obviously" true.

### Act Export

The Coq backend for Act exports the constructor and behaviours of an Act spec as a set of [inductive
propositions](https://softwarefoundations.cis.upenn.edu/lf-current/IndProp.html). Numbers are


## Future Work

### Automated Spec Generation

Act is designed to be simple and explicit. While this supports automated analysis based on the act
specifications, it does mean that writing specifications by hand often involves quite some
boilerplate. In many cases we are mostly interested in whether a given bytecode object
satisfies some high level properties, and keeping both the implementation and specification in sync
can introduce unwanted overhead to the development process.

For this reason we intend to build an automated spec generation engine into hevm that will utilise
the symbolic execution engine to produce an exhaustive description of all possible execution paths
as a set of act specifications. This should allow for fast iteration on the implementation, while
allowing for high level analysis of that implementation with Coq and the Act smt backend.

There are some additional benefits to this approach. The current symbolic execution backend
represents our first attempt at a bytecode level proof engine for act. Unfortunately while building
this out we encountered a fundamental issue: while act specs are expressed in terms of unbounded
integers, the symbolic execution engine in hevm uses bitvectors. This means that checking
equivalence between a given bytecode object and a set of act specs requires conversions from
integers to bitvectors. While this is tractable for simple specs, it quickly overwhelms the SMT
solver for any non-trivial contract (including any safe arithmetic!).

An automated spec generation engine allows us to nicely sidestep this issue, we no longer have to
prove equivalence between bytecode and specs, since the specs themselves have been generated
directly from the bytecode and are therefore "correct by construction". Even in the case where specs
have been written by hand, we would still only need to prove equivalence between two sets of specs
(both of which are written in terms of Integers), once again allowing us to avoid the troublesome
`bv_to_int` and `int_to_bv` smt operations.

### Automated Checks for Spec Integrity

There are currently many specs that typecheck but are still malformed and would invalidate the
proofs derived from them. We intend to add automated analysis passes to detect issues of this kind.
At the moment we currently have the following planned:

- Arithmetic overflow detection ([#109](https://github.com/ethereum/act/issues/111))
- Case consistency checks ([#110](https://github.com/ethereum/act/issues/111))
- Collisions in mapping assignments ([#111](https://github.com/ethereum/act/issues/111))

### Support for Dynamic / Compound Types

While we have some support at the syntax level for specifications involving dynamic types (e.g. `string`
or `bytes`), the various proof backends do not currently support proof involving these types.

We also intend to add support for compound types (e.g. array / struct / tuple) to the language and
proof backends.

### Multi Contract Specifications

Similarly to dynamic and compound types, while syntax does exist that allows for specification of
multi contract systems, these features are not well supported in the various analysis backends.

### Rounding Error Analysis

Understanding the impact of rounding error in a smart contract is a critical task for secure
development.  As we saw in the `AMM` example above, numeric error introduced by precision loss can
result in unexpected violations of important security properties.

There are generally two properties of interest:

- The direction of the rounding error (who loses out)
- The size of the rounding error (by how much do they lose)

We intend to allow users to specify properties relating to rounding by introducing a new operator
(e.g. `exact`, or `toReal`), which would indicate that the numeric expression contained within
should be expressed in various backends using Reals instead of Ints. This would for example allow
for properties that assert statements about the size and direction of the difference between the
result of the calculation over the real numbers and it's rounded result when expressed over the
integers.

For a manual example of a similar analysis, see the [uniswap v1
model](https://github.com/runtimeverification/verified-smart-contracts/blob/uniswap/uniswap/x-y-k.pdf)
produced by Runtime Verification.

### Calls Into Unknown Code

Real world smart contracts must often make calls into unknown code, whether for simple tasks like an
eth or token transfer, or for more complex actions (e.g. delegation of control for a flash loan).
Each time they do so, they pass control to potentially malicious code that can make arbitrary
modifications to the execution context, something that obviously has deep implications for the
security of the calling contract. If we wish to prove security properties about realistic
smart contracts with Act, we must therefore be able to specify behaviour that includes such calls.

We intend to introduce language constructs and verification routines that will allow specification
and proof of properties relating to such contracts. Some ideas can be found
[here](https://github.com/ethereum/act/issues/18).

### Loops and Loop Invariants

Although generally inadvisable, loops are sometimes unavoidable when developing smart contracts
(e.g. numeric routines). We intend to introduce syntax and verification routines that allow
specification and proof for loop invariants.

Some early thoughts and ideas can be found in these github issues
[#2](https://github.com/ethereum/act/issues/2), [#3](https://github.com/ethereum/act/issues/3).
